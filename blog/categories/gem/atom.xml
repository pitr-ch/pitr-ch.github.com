<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: gem | Pitr.ch]]></title>
  <link href="http://blog.pitr.ch/blog/categories/gem/atom.xml" rel="self"/>
  <link href="http://blog.pitr.ch/"/>
  <updated>2014-02-08T17:06:11+01:00</updated>
  <id>http://blog.pitr.ch/</id>
  <author>
    <name><![CDATA[Petr Chalupa]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Algebrick - Bumping to v0.2 with new better type-defining-DSL]]></title>
    <link href="http://blog.pitr.ch/blog/2013/09/16/algebrick-bumping-to-v0-dot-2-with-new-better-type-defining-dsl/"/>
    <updated>2013-09-16T22:03:00+02:00</updated>
    <id>http://blog.pitr.ch/blog/2013/09/16/algebrick-bumping-to-v0-dot-2-with-new-better-type-defining-dsl</id>
    <content type="html"><![CDATA[<p>Finely I&#39;ve got an idea how to improve the old-not-so-good-DSL for Algebraic type definition.</p>

<!-- more -->

<p>With old DSL you would define Tree type as follows.</p>
<div class="highlight"><pre><code class="ruby"><span class="kp">include</span> <span class="ss">Algebrick</span><span class="p">:</span><span class="ss">:DSL</span>
<span class="n">type_def</span> <span class="k">do</span>
  <span class="n">tree</span> <span class="o">===</span> <span class="n">tip</span> <span class="o">|</span> <span class="n">node</span><span class="p">(</span><span class="ss">value</span><span class="p">:</span> <span class="no">Object</span><span class="p">,</span> <span class="ss">left</span><span class="p">:</span> <span class="n">tree</span><span class="p">,</span> <span class="ss">right</span><span class="p">:</span> <span class="n">tree</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>
<p>Although this looks quite nice and it&#39;s concise, it magically defines constants <code>Tree</code>, <code>Tip</code> and <code>Node</code>. Later when you come back to the code it&#39;s hard to  find where the constants are being defined. There is no <code>Tree = #something</code> in the source code. IDEs like RubyMine won&#39;t find the definition either.</p>

<p>I&#39;ve tried to improve the situation with manually setting the constants (this was never released).</p>
<div class="highlight"><pre><code class="ruby"><span class="no">Tree</span><span class="p">,</span> <span class="no">Tip</span><span class="p">,</span> <span class="no">Node</span> <span class="o">=</span> <span class="n">type_def</span> <span class="k">do</span>
  <span class="n">tree</span> <span class="o">===</span> <span class="n">tip</span> <span class="o">|</span> <span class="n">node</span><span class="p">(</span><span class="ss">value</span><span class="p">:</span> <span class="no">Object</span><span class="p">,</span> <span class="ss">left</span><span class="p">:</span> <span class="n">tree</span><span class="p">,</span> <span class="ss">right</span><span class="p">:</span> <span class="n">tree</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>
<p>But this has several other flows:</p>

<ol>
<li> If order of <code>tip</code> and <code>node</code> is changed in the definition, newly created types will end up in wrong constants since they are being returned by <code>#type_def</code> in order of first mention.</li>
<li> When more types are being defined in <code>#type_def</code>&#39;s block it will get messy very soon.</li>
</ol>

<p>Then I&#39;ve finally realized that because <code>#instance_eval</code> and <code>#instance_exec</code> does not change the <code>Module.nesting</code> of the blocks, the block can be evaluated inside a scope with DSL methods keeping the constants defined in original place. This behavior allows the following definition of Algebraic types.</p>
<div class="highlight"><pre><code class="ruby"><span class="no">Tree</span> <span class="o">=</span> <span class="no">Algebrick</span><span class="o">.</span><span class="n">type</span> <span class="k">do</span> <span class="o">|</span><span class="n">tree</span><span class="o">|</span>
  <span class="no">Tip</span>  <span class="o">=</span> <span class="n">type</span>
  <span class="no">Node</span> <span class="o">=</span> <span class="n">type</span> <span class="p">{</span> <span class="n">fields</span> <span class="ss">value</span><span class="p">:</span> <span class="no">Object</span><span class="p">,</span> <span class="ss">left</span><span class="p">:</span> <span class="n">tree</span><span class="p">,</span> <span class="ss">right</span><span class="p">:</span> <span class="n">tree</span> <span class="p">}</span>

  <span class="n">variants</span> <span class="no">Tip</span><span class="p">,</span> <span class="no">Node</span>
<span class="k">end</span>
</code></pre></div>
<p>It&#39;s been released in version 0.2.0.</p>

<h2>Version 0.2.2</h2>

<p>Version 0.2.1 just fixes release date of the gem. Version 0.2.2 adds minor improvement to the DSL. Field readers on products can be defined in DSL with methods <code>#readers *names</code> or <code>#all_readers</code> for all of them.</p>
<div class="highlight"><pre><code class="ruby"><span class="no">Node</span> <span class="o">=</span> <span class="n">type</span> <span class="k">do</span>
  <span class="n">fields</span> <span class="ss">value</span><span class="p">:</span> <span class="no">Object</span><span class="p">,</span> <span class="ss">left</span><span class="p">:</span> <span class="n">tree</span><span class="p">,</span> <span class="ss">right</span><span class="p">:</span> <span class="n">tree</span>
  <span class="n">all_readers</span>
<span class="k">end</span>
</code></pre></div>
<p>I hope you like the new DSL. </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Justified - add missing causes to exceptions]]></title>
    <link href="http://blog.pitr.ch/blog/2013/06/01/justified-add-missing-causes-to-exceptions/"/>
    <updated>2013-06-01T19:52:00+02:00</updated>
    <id>http://blog.pitr.ch/blog/2013/06/01/justified-add-missing-causes-to-exceptions</id>
    <content type="html"><![CDATA[<p>I&#39;ve just published a new gem called <code>justified</code> which is adding missing causes to Ruby exceptions.
When an exception is risen because of another one it is stored in the new one, and backtrace is appended with following: </p>
<div class="highlight"><pre><code class="text">from caused by: (AnError) an ugly bug
from justified.rb:83:in `bad_code&#39;
from     ... skipped 4 lines
</code></pre></div>
<!-- more -->

<h2>Example</h2>

<p>Let&#39;s have following snippet:</p>
<div class="highlight"><pre><code class="ruby"><span class="k">class</span> <span class="nc">AnError</span> <span class="o">&lt;</span> <span class="no">StadardError</span><span class="p">;</span> <span class="k">end</span>

<span class="k">def</span> <span class="nf">bad_code</span>
  <span class="k">raise</span> <span class="no">AnError</span><span class="p">,</span> <span class="s1">&#39;an ugly bug&#39;</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">handle_error</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
  <span class="k">raise</span> <span class="no">AnError</span><span class="p">,</span> <span class="s1">&#39;something went wrong&#39;</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">do_something</span>
  <span class="n">bad_code</span>
<span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">error</span>
  <span class="n">handle_error</span> <span class="n">error</span>
<span class="k">end</span>

<span class="n">do_something</span>
</code></pre></div>
<p>When called it will produce:</p>
<div class="highlight"><pre><code class="text">justified.rb:93:in `handle_error&#39;: something went wrong (AnError)
    from justified.rb:89:in `rescue in do_something&#39;
    from justified.rb:87:in `do_something&#39;
    from justified.rb:96:in `&lt;top (required)&gt;&#39;
    from -e:1:in `load&#39;
    from -e:1:in `&lt;main&gt;&#39;
</code></pre></div>
<p>The real problem <code>an ugly bug</code> is <strong>hidden</strong>. What will happen when <code>justified</code> is used?</p>
<div class="highlight"><pre><code class="ruby"><span class="nb">require</span> <span class="s1">&#39;justified/stadard_error&#39;</span>

<span class="c1"># ... rest of the snipper</span>
</code></pre></div>
<p>It will produce:</p>
<div class="highlight"><pre><code class="text">justified.rb:93:in `handle_error&#39;: something went wrong (AnError)
    from justified.rb:89:in `rescue in do_something&#39;
    from justified.rb:87:in `do_something&#39;
    from justified.rb:96:in `&lt;top (required)&gt;&#39;
    from -e:1:in `load&#39;
    from -e:1:in `&lt;main&gt;&#39;
    from caused by: (AnError) an ugly bug
    from justified.rb:83:in `bad_code&#39;
    from     ... skipped 4 lines
</code></pre></div>
<p>Of course causes can be concatenated. </p>

<h2>Usage</h2>

<ul>
<li>  <code>require &#39;justified&#39;</code> to include <code>Justified::Error</code> to any exception you need manually</li>
<li>  <code>require &#39;justified/standard_error&#39;</code> to have causes in all exceptions which are kind of <code>StandardError</code></li>
</ul>

<h3>Behavior</h3>

<p>When an exception is risen inside rescue block a cause is automatically recorded.</p>
<div class="highlight"><pre><code class="ruby"><span class="n">e</span> <span class="o">=</span> <span class="k">begin</span>
      <span class="k">raise</span> <span class="s1">&#39;bug&#39;</span>
    <span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">error</span>
      <span class="k">raise</span> <span class="s1">&#39;this does not work&#39;</span>
    <span class="k">end</span> <span class="k">rescue</span> <span class="vg">$!</span>
<span class="n">e</span><span class="o">.</span><span class="n">cause</span><span class="o">.</span><span class="n">message</span> <span class="o">==</span> <span class="s1">&#39;bug&#39;</span> <span class="c1"># =&gt; true</span>
</code></pre></div>
<p>Cause can be set explicitly.</p>
<div class="highlight"><pre><code class="ruby"><span class="n">e</span> <span class="o">=</span> <span class="k">begin</span>
      <span class="k">raise</span> <span class="s1">&#39;bug&#39;</span>
    <span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">error</span>
      <span class="k">raise</span> <span class="no">StandardError</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;this does not work&#39;</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span>
    <span class="k">end</span> <span class="k">rescue</span> <span class="vg">$!</span>
<span class="n">e</span><span class="o">.</span><span class="n">cause</span><span class="o">.</span><span class="n">message</span> <span class="o">==</span> <span class="s1">&#39;bug&#39;</span> <span class="c1"># =&gt; true</span>
</code></pre></div>
<p>Or if signature of <code>.new</code> is changed cause can be set with a setter <code>#cause=</code></p>
<div class="highlight"><pre><code class="ruby"><span class="k">class</span> <span class="nc">InspectingError</span> <span class="o">&lt;</span> <span class="no">StandardError</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">object</span><span class="p">)</span>
    <span class="k">super</span> <span class="n">object</span><span class="o">.</span><span class="n">inspect</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">e</span> <span class="o">=</span> <span class="k">begin</span>
      <span class="k">raise</span> <span class="s1">&#39;bug&#39;</span>
    <span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">error</span>
      <span class="k">raise</span> <span class="no">InspectingError</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">a</span><span class="p">:</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">tap</span> <span class="p">{</span> <span class="o">|</span><span class="n">e</span><span class="o">|</span> <span class="n">e</span><span class="o">.</span><span class="n">cause</span> <span class="o">=</span> <span class="n">error</span> <span class="p">}</span>
    <span class="k">end</span> <span class="k">rescue</span> <span class="vg">$!</span>
<span class="n">e</span><span class="o">.</span><span class="n">cause</span><span class="o">.</span><span class="n">message</span> <span class="o">==</span> <span class="s1">&#39;bug&#39;</span> <span class="c1"># =&gt; true</span>
</code></pre></div>
<p>and</p>
<div class="highlight"><pre><code class="ruby"><span class="n">e</span> <span class="o">=</span> <span class="k">begin</span>
      <span class="k">raise</span> <span class="s1">&#39;bug&#39;</span>
    <span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">error</span>
      <span class="k">raise</span> <span class="no">InspectingError</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">a</span><span class="p">:</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
    <span class="k">end</span> <span class="k">rescue</span> <span class="vg">$!</span>
<span class="n">e</span><span class="o">.</span><span class="n">cause</span><span class="o">.</span><span class="n">message</span> <span class="o">==</span> <span class="s1">&#39;bug&#39;</span> <span class="c1"># =&gt; true</span>
</code></pre></div>
<p>will work as well.</p>

<h2>Do you wish to know more?</h2>

<ul>
<li>  Documentation: <a href="http://blog.pitr.ch/justified">http://blog.pitr.ch/justified</a></li>
<li>  Source: <a href="https://github.com/pitr-ch/justified">https://github.com/pitr-ch/justified</a></li>
<li>  Blog: <a href="http://blog.pitr.ch/blog/categories/justified/">http://blog.pitr.ch/blog/categories/justified/</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Praise - bump to version 0.0.3]]></title>
    <link href="http://blog.pitr.ch/blog/2013/06/01/praise-bump-to-version-0-dot-0-3/"/>
    <updated>2013-06-01T19:05:00+02:00</updated>
    <id>http://blog.pitr.ch/blog/2013/06/01/praise-bump-to-version-0-dot-0-3</id>
    <content type="html"><![CDATA[<!-- more -->

<h2>Enabling and Disabling</h2>

<p>Method <code>#enable=</code> has been given to <code>praise</code> in this version. Use <code>praise.enable = true</code> to install its hook to <code>Kernel</code> 
and <code>praise.enable = false</code> to uninstall it.</p>
<div class="highlight"><pre><code class="ruby"><span class="no">Praise</span> <span class="o">=</span> <span class="no">PraiseImpl</span><span class="o">.</span><span class="n">new</span><span class="p">(</span>
    <span class="s1">&#39;path_to_ignore_file.yml&#39;</span><span class="p">,</span> 
    <span class="kp">false</span><span class="p">)</span> <span class="c1"># to instantiate it disabled</span>
<span class="no">Praise</span><span class="o">.</span><span class="n">enable</span> <span class="o">=</span> <span class="kp">true</span>   
</code></pre></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Algebrick - bump to version 0.1.2]]></title>
    <link href="http://blog.pitr.ch/blog/2013/06/01/algebrick-bump-to-version-0-1-2/"/>
    <updated>2013-06-01T17:22:00+02:00</updated>
    <id>http://blog.pitr.ch/blog/2013/06/01/algebrick-bump-to-version-0-1-2</id>
    <content type="html"><![CDATA[<!-- more -->

<h2>Call <code>#type_def</code> directly</h2>

<p><code>Algebraic::DSL</code> module does not have to be extended into your module to access <code>#type_def</code> any more.
It can be now called directly with passing the base module to define the new types.</p>
<div class="highlight"><pre><code class="ruby"><span class="no">Algebrick</span><span class="o">.</span><span class="n">type_def</span> <span class="nb">self</span> <span class="k">do</span>
  <span class="n">boolean</span> <span class="o">===</span> <span class="no">TrueClass</span> <span class="o">|</span> <span class="no">FalseClass</span>
<span class="k">end</span>
</code></pre></div>
<h2>Wrong field</h2>

<p>When wrong field is accessed it will now raise an <code>ArgummentError</code> instead of silently returning <code>nil</code></p>
<div class="highlight"><pre><code class="ruby"><span class="no">Algebrick</span><span class="o">.</span><span class="n">type_def</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">tree</span> <span class="o">===</span> <span class="n">empty</span> <span class="o">|</span> <span class="n">tree</span><span class="p">(</span><span class="ss">value</span><span class="p">:</span> <span class="nb">Integer</span><span class="p">,</span> <span class="ss">left</span><span class="p">:</span> <span class="n">tree</span><span class="p">,</span> <span class="ss">right</span><span class="p">:</span> <span class="n">tree</span><span class="p">)</span>
<span class="k">end</span>
<span class="no">Tree</span><span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="no">Empty</span><span class="p">,</span> <span class="no">Empty</span><span class="o">][</span><span class="ss">:middle</span><span class="o">]</span> <span class="k">rescue</span> <span class="vg">$!</span> 
<span class="c1"># =&gt; #&lt;ArgumentError: uknown field :middle&gt;</span>
</code></pre></div>
<h2>Access fields by method</h2>

<p>Call <code>#add_all_field_method_accessors</code> on a product type to get access to fields by methods.</p>
<div class="highlight"><pre><code class="ruby"><span class="no">Tree</span><span class="o">.</span><span class="n">add_all_field_method_accessors</span>
<span class="no">Tree</span><span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="no">Empty</span><span class="p">,</span> <span class="no">Empty</span><span class="o">].</span><span class="n">left</span>   <span class="c1"># =&gt; Empty</span>
</code></pre></div>
<p>There are also methods <code>add_field_method_accessor</code> and <code>add_field_method_accessors</code> to add accessor/s selectively.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Algebrick - bump to version 0.1.1]]></title>
    <link href="http://blog.pitr.ch/blog/2013/06/01/algebrick-bump-to-version-0-1-1/"/>
    <updated>2013-06-01T17:22:00+02:00</updated>
    <id>http://blog.pitr.ch/blog/2013/06/01/algebrick-bump-to-version-0-1-1</id>
    <content type="html"><![CDATA[<!-- more -->

<h2>Method <code>#+</code> is deprecated</h2>
<div class="highlight"><pre><code class="ruby"><span class="no">Leaf</span><span class="o">.</span><span class="p">(</span><span class="o">~</span><span class="n">any</span><span class="p">)</span> <span class="o">+-&gt;</span> <span class="n">v</span> <span class="p">{</span> <span class="n">v</span><span class="o">*</span><span class="mi">2</span> <span class="p">}</span>
</code></pre></div>
<p><code>#-</code>, <code>#&gt;&gt;</code> and <code>#case</code> should be used instead</p>
<div class="highlight"><pre><code class="ruby"><span class="no">Leaf</span><span class="o">.</span><span class="p">(</span><span class="o">~</span><span class="n">any</span><span class="p">)</span> <span class="o">--&gt;</span> <span class="n">v</span> <span class="p">{</span> <span class="n">v</span><span class="o">*</span><span class="mi">2</span> <span class="p">}</span>
<span class="no">Leaf</span><span class="o">.</span><span class="p">(</span><span class="o">~</span><span class="n">any</span><span class="p">)</span> <span class="o">&gt;&gt;-&gt;</span> <span class="n">v</span> <span class="p">{</span> <span class="n">v</span><span class="o">*</span><span class="mi">2</span> <span class="p">}</span>
<span class="no">Leaf</span><span class="o">.</span><span class="p">(</span><span class="o">~</span><span class="n">any</span><span class="p">)</span><span class="o">.</span><span class="n">case</span> <span class="p">{</span> <span class="o">|</span><span class="n">v</span><span class="o">|</span> <span class="n">v</span><span class="o">*</span><span class="mi">2</span> <span class="p">}</span>
</code></pre></div>
<h2>Delegation from Types</h2>

<p><code>#-</code>, <code>#&gt;&gt;</code> and <code>#case</code> are now delegated from types, it simplifies calls on atom types</p>
<div class="highlight"><pre><code class="ruby"><span class="no">None</span><span class="o">.</span><span class="n">to_m</span> <span class="o">&gt;&gt;</span> <span class="kp">nil</span> <span class="c1"># to_m can be omitted</span>
<span class="no">None</span> <span class="o">&gt;&gt;</span> <span class="kp">nil</span>        
</code></pre></div>]]></content>
  </entry>
  
</feed>
