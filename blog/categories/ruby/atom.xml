<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Pitr.ch]]></title>
  <link href="http://blog.pitr.ch/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://blog.pitr.ch/"/>
  <updated>2013-06-14T10:49:58+02:00</updated>
  <id>http://blog.pitr.ch/</id>
  <author>
    <name><![CDATA[Petr Chalupa]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to get object reference from inspection-string]]></title>
    <link href="http://blog.pitr.ch/blog/2013/06/03/how-to-get-object-reference-from-inspection-string/"/>
    <updated>2013-06-03T19:22:00+02:00</updated>
    <id>http://blog.pitr.ch/blog/2013/06/03/how-to-get-object-reference-from-inspection-string</id>
    <content type="html"><![CDATA[<!-- more -->

<p>Suppose there is a test failing and only an inspection string is shown in the error message.</p>
<div class="highlight"><pre><code class="text">#&lt;Class:0x007ff706e7eb68&gt;
</code></pre></div>
<p>It would be very convenient to retrieve a reference to the object for further inspection.
The following snippet will give you the object if it isn&#39;t garbage-collected yet.</p>
<div class="highlight"><pre><code class="ruby"><span class="no">ObjectSpace</span><span class="o">.</span><span class="n">_id2ref</span> <span class="s1">&#39;0x007ff706e7eb68&#39;</span><span class="o">.</span><span class="n">to_i</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
</code></pre></div>
<p>If you are asking about the strange bit shift <code>&gt;&gt; 1</code> as I am, I&#39;ll humbly point you to 
<a href="http://stackoverflow.com/questions/2818602/in-ruby-why-does-inspect-print-out-some-kind-of-object-id-which-is-different">http://stackoverflow.com/questions/2818602/in-ruby-why-does-inspect-print-out-some-kind-of-object-id-which-is-different</a> 
where you can find some explanation.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Make traps for future mistakes]]></title>
    <link href="http://blog.pitr.ch/blog/2013/06/02/make-traps-for-future-mistakes/"/>
    <updated>2013-06-02T10:58:00+02:00</updated>
    <id>http://blog.pitr.ch/blog/2013/06/02/make-traps-for-future-mistakes</id>
    <content type="html"><![CDATA[<p>I love to raise <code>ArgumentErrors</code>, <code>TypeErrors</code>, etc. whenever an API is misused. It prevents a lot of bugs. 
Recently I thought of another use for exceptions. </p>

<!-- more -->

<h2>Traps for future mistakes</h2>

<p>Suppose you are a developer of a gem and a method needs to be deprecated. Gem has version 0.1.3 and 
the method needs to warn about deprecation until version 0.2 and to be removed in version 0.2. 
It could be marked with <code>TODO</code> for removal in 0.2. Do you think that <code>TODO</code> will ensure timed removal? 
I don&#39;t. </p>

<p>I use exceptions to trap myself so I cannot do such mistakes.</p>
<div class="highlight"><pre><code class="ruby"><span class="k">raise</span> <span class="s1">&#39;remove deprecation&#39;</span> <span class="k">if</span> <span class="no">Algebrick</span><span class="o">.</span><span class="n">version</span> <span class="o">&gt;=</span> <span class="ss">Gem</span><span class="p">:</span><span class="ss">:Version</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;0.2&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">+</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
  <span class="nb">warn</span> <span class="s1">&#39;a_matcher +-&gt; {} is deprecated, it\&#39;ll be removed in 0.2&#39;</span>
  <span class="nb">self</span> <span class="o">-</span> <span class="n">block</span>
<span class="k">end</span>
</code></pre></div>
<p>If I use this I cannot forget about the deprecation removal. The gem will simply error when I bump version to 0.2 
telling me what I&#39;ve forgotten to fix.</p>

<h2>Another examples</h2>

<ul>
<li><p><strong>Monkey patch</strong> - When writing a monkey patch, a monkey patch should error when patched gem goes outside of
version range which was tested to work with the patch.</p>
<div class="highlight"><pre><code class="ruby"><span class="n">range</span> <span class="o">=</span> <span class="ss">Gem</span><span class="p">:</span><span class="ss">:Version</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;0.1&#39;</span><span class="p">)</span> <span class="o">.</span><span class="n">.</span><span class="o">.</span> <span class="ss">Gem</span><span class="p">:</span><span class="ss">:Version</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;0.3&#39;</span><span class="p">)</span>
<span class="n">range</span><span class="o">.</span><span class="n">cover?</span> <span class="ss">Gem</span><span class="p">:</span><span class="ss">:Version</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">a_patched_gem_version</span><span class="p">)</span> <span class="ow">or</span>
    <span class="k">raise</span> <span class="s2">&quot;monkey eats only banana version </span><span class="si">#{</span><span class="n">range</span><span class="si">}</span><span class="s2">&quot;</span>
</code></pre></div></li>
<li><p><strong>Internal API usage</strong> - Suppose a code is tied with an internal methods of Rails 3.0 and it&#39;s known that
an upgrade to 3.2 is planned at some point. An error should be thrown when Rails are updated.</p>
<div class="highlight"><pre><code class="ruby"><span class="ss">Gem</span><span class="p">:</span><span class="ss">:Version</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="no">Rails</span><span class="o">.</span><span class="n">version</span><span class="p">)</span> <span class="o">&lt;</span> <span class="ss">Gem</span><span class="p">:</span><span class="ss">:Version</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;3.1&#39;</span><span class="p">)</span> <span class="ow">or</span>
    <span class="k">raise</span> <span class="s1">&#39;revisit api usage&#39;</span>
</code></pre></div></li>
</ul>

<h2>Caution</h2>

<p>Checks like these should be done in class or module scope to be evaluated only once when loading. 
They should not be placed inside methods.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Justified - add missing causes to exceptions]]></title>
    <link href="http://blog.pitr.ch/blog/2013/06/01/justified-add-missing-causes-to-exceptions/"/>
    <updated>2013-06-01T19:52:00+02:00</updated>
    <id>http://blog.pitr.ch/blog/2013/06/01/justified-add-missing-causes-to-exceptions</id>
    <content type="html"><![CDATA[<p>I&#39;ve just published a new gem called <code>justified</code> which is adding missing causes to Ruby exceptions.
When an exception is risen because of another one it is stored in the new one, and backtrace is appended with following: </p>
<div class="highlight"><pre><code class="text">from caused by: (AnError) an ugly bug
from justified.rb:83:in `bad_code&#39;
from     ... skipped 4 lines
</code></pre></div>
<!-- more -->

<h2>Example</h2>

<p>Let&#39;s have following snippet:</p>
<div class="highlight"><pre><code class="ruby"><span class="k">class</span> <span class="nc">AnError</span> <span class="o">&lt;</span> <span class="no">StadardError</span><span class="p">;</span> <span class="k">end</span>

<span class="k">def</span> <span class="nf">bad_code</span>
  <span class="k">raise</span> <span class="no">AnError</span><span class="p">,</span> <span class="s1">&#39;an ugly bug&#39;</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">handle_error</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
  <span class="k">raise</span> <span class="no">AnError</span><span class="p">,</span> <span class="s1">&#39;something went wrong&#39;</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">do_something</span>
  <span class="n">bad_code</span>
<span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">error</span>
  <span class="n">handle_error</span> <span class="n">error</span>
<span class="k">end</span>

<span class="n">do_something</span>
</code></pre></div>
<p>When called it will produce:</p>
<div class="highlight"><pre><code class="text">justified.rb:93:in `handle_error&#39;: something went wrong (AnError)
    from justified.rb:89:in `rescue in do_something&#39;
    from justified.rb:87:in `do_something&#39;
    from justified.rb:96:in `&lt;top (required)&gt;&#39;
    from -e:1:in `load&#39;
    from -e:1:in `&lt;main&gt;&#39;
</code></pre></div>
<p>The real problem <code>an ugly bug</code> is <strong>hidden</strong>. What will happen when <code>justified</code> is used?</p>
<div class="highlight"><pre><code class="ruby"><span class="nb">require</span> <span class="s1">&#39;justified/stadard_error&#39;</span>

<span class="c1"># ... rest of the snipper</span>
</code></pre></div>
<p>It will produce:</p>
<div class="highlight"><pre><code class="text">justified.rb:93:in `handle_error&#39;: something went wrong (AnError)
    from justified.rb:89:in `rescue in do_something&#39;
    from justified.rb:87:in `do_something&#39;
    from justified.rb:96:in `&lt;top (required)&gt;&#39;
    from -e:1:in `load&#39;
    from -e:1:in `&lt;main&gt;&#39;
    from caused by: (AnError) an ugly bug
    from justified.rb:83:in `bad_code&#39;
    from     ... skipped 4 lines
</code></pre></div>
<p>Of course causes can be concatenated. </p>

<h2>Usage</h2>

<ul>
<li>  <code>require &#39;justified&#39;</code> to include <code>Justified::Error</code> to any exception you need manually</li>
<li>  <code>require &#39;justified/standard_error&#39;</code> to have causes in all exceptions which are kind of <code>StandardError</code></li>
</ul>

<h3>Behavior</h3>

<p>When an exception is risen inside rescue block a cause is automatically recorded.</p>
<div class="highlight"><pre><code class="ruby"><span class="n">e</span> <span class="o">=</span> <span class="k">begin</span>
      <span class="k">raise</span> <span class="s1">&#39;bug&#39;</span>
    <span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">error</span>
      <span class="k">raise</span> <span class="s1">&#39;this does not work&#39;</span>
    <span class="k">end</span> <span class="k">rescue</span> <span class="vg">$!</span>
<span class="n">e</span><span class="o">.</span><span class="n">cause</span><span class="o">.</span><span class="n">message</span> <span class="o">==</span> <span class="s1">&#39;bug&#39;</span> <span class="c1"># =&gt; true</span>
</code></pre></div>
<p>Cause can be set explicitly.</p>
<div class="highlight"><pre><code class="ruby"><span class="n">e</span> <span class="o">=</span> <span class="k">begin</span>
      <span class="k">raise</span> <span class="s1">&#39;bug&#39;</span>
    <span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">error</span>
      <span class="k">raise</span> <span class="no">StandardError</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;this does not work&#39;</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span>
    <span class="k">end</span> <span class="k">rescue</span> <span class="vg">$!</span>
<span class="n">e</span><span class="o">.</span><span class="n">cause</span><span class="o">.</span><span class="n">message</span> <span class="o">==</span> <span class="s1">&#39;bug&#39;</span> <span class="c1"># =&gt; true</span>
</code></pre></div>
<p>Or if signature of <code>.new</code> is changed cause can be set with a setter <code>#cause=</code></p>
<div class="highlight"><pre><code class="ruby"><span class="k">class</span> <span class="nc">InspectingError</span> <span class="o">&lt;</span> <span class="no">StandardError</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">object</span><span class="p">)</span>
    <span class="k">super</span> <span class="n">object</span><span class="o">.</span><span class="n">inspect</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">e</span> <span class="o">=</span> <span class="k">begin</span>
      <span class="k">raise</span> <span class="s1">&#39;bug&#39;</span>
    <span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">error</span>
      <span class="k">raise</span> <span class="no">InspectingError</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">a</span><span class="p">:</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">tap</span> <span class="p">{</span> <span class="o">|</span><span class="n">e</span><span class="o">|</span> <span class="n">e</span><span class="o">.</span><span class="n">cause</span> <span class="o">=</span> <span class="n">error</span> <span class="p">}</span>
    <span class="k">end</span> <span class="k">rescue</span> <span class="vg">$!</span>
<span class="n">e</span><span class="o">.</span><span class="n">cause</span><span class="o">.</span><span class="n">message</span> <span class="o">==</span> <span class="s1">&#39;bug&#39;</span> <span class="c1"># =&gt; true</span>
</code></pre></div>
<p>and</p>
<div class="highlight"><pre><code class="ruby"><span class="n">e</span> <span class="o">=</span> <span class="k">begin</span>
      <span class="k">raise</span> <span class="s1">&#39;bug&#39;</span>
    <span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">error</span>
      <span class="k">raise</span> <span class="no">InspectingError</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">a</span><span class="p">:</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
    <span class="k">end</span> <span class="k">rescue</span> <span class="vg">$!</span>
<span class="n">e</span><span class="o">.</span><span class="n">cause</span><span class="o">.</span><span class="n">message</span> <span class="o">==</span> <span class="s1">&#39;bug&#39;</span> <span class="c1"># =&gt; true</span>
</code></pre></div>
<p>will work as well.</p>

<h2>Do you wish to know more?</h2>

<ul>
<li>  Documentation: <a href="http://blog.pitr.ch/justified">http://blog.pitr.ch/justified</a></li>
<li>  Source: <a href="https://github.com/pitr-ch/justified">https://github.com/pitr-ch/justified</a></li>
<li>  Blog: <a href="http://blog.pitr.ch/blog/categories/justified/">http://blog.pitr.ch/blog/categories/justified/</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Praise - bump to version 0.0.3]]></title>
    <link href="http://blog.pitr.ch/blog/2013/06/01/praise-bump-to-version-0-dot-0-3/"/>
    <updated>2013-06-01T19:05:00+02:00</updated>
    <id>http://blog.pitr.ch/blog/2013/06/01/praise-bump-to-version-0-dot-0-3</id>
    <content type="html"><![CDATA[<!-- more -->

<h2>Enabling and Disabling</h2>

<p>Method <code>#enable=</code> has been given to <code>praise</code> in this version. Use <code>praise.enable = true</code> to install its hook to <code>Kernel</code> 
and <code>praise.enable = false</code> to uninstall it.</p>
<div class="highlight"><pre><code class="ruby"><span class="no">Praise</span> <span class="o">=</span> <span class="no">PraiseImpl</span><span class="o">.</span><span class="n">new</span><span class="p">(</span>
    <span class="s1">&#39;path_to_ignore_file.yml&#39;</span><span class="p">,</span> 
    <span class="kp">false</span><span class="p">)</span> <span class="c1"># to instantiate it disabled</span>
<span class="no">Praise</span><span class="o">.</span><span class="n">enable</span> <span class="o">=</span> <span class="kp">true</span>   
</code></pre></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Algebrick - bump to version 0.1.2]]></title>
    <link href="http://blog.pitr.ch/blog/2013/06/01/algebrick-bump-to-version-0-1-2/"/>
    <updated>2013-06-01T17:22:00+02:00</updated>
    <id>http://blog.pitr.ch/blog/2013/06/01/algebrick-bump-to-version-0-1-2</id>
    <content type="html"><![CDATA[<!-- more -->

<h2>Call <code>#type_def</code> directly</h2>

<p><code>Algebraic::DSL</code> module does not have to be extended into your module to access <code>#type_def</code> any more.
It can be now called directly with passing the base module to define the new types.</p>
<div class="highlight"><pre><code class="ruby"><span class="no">Algebrick</span><span class="o">.</span><span class="n">type_def</span> <span class="nb">self</span> <span class="k">do</span>
  <span class="n">boolean</span> <span class="o">===</span> <span class="no">TrueClass</span> <span class="o">|</span> <span class="no">FalseClass</span>
<span class="k">end</span>
</code></pre></div>
<h2>Wrong field</h2>

<p>When wrong field is accessed it will now raise an <code>ArgummentError</code> instead of silently returning <code>nil</code></p>
<div class="highlight"><pre><code class="ruby"><span class="no">Algebrick</span><span class="o">.</span><span class="n">type_def</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">tree</span> <span class="o">===</span> <span class="n">empty</span> <span class="o">|</span> <span class="n">tree</span><span class="p">(</span><span class="ss">value</span><span class="p">:</span> <span class="nb">Integer</span><span class="p">,</span> <span class="ss">left</span><span class="p">:</span> <span class="n">tree</span><span class="p">,</span> <span class="ss">right</span><span class="p">:</span> <span class="n">tree</span><span class="p">)</span>
<span class="k">end</span>
<span class="no">Tree</span><span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="no">Empty</span><span class="p">,</span> <span class="no">Empty</span><span class="o">][</span><span class="ss">:middle</span><span class="o">]</span> <span class="k">rescue</span> <span class="vg">$!</span> 
<span class="c1"># =&gt; #&lt;ArgumentError: uknown field :middle&gt;</span>
</code></pre></div>
<h2>Access fields by method</h2>

<p>Call <code>#add_all_field_method_accessors</code> on a product type to get access to fields by methods.</p>
<div class="highlight"><pre><code class="ruby"><span class="no">Tree</span><span class="o">.</span><span class="n">add_all_field_method_accessors</span>
<span class="no">Tree</span><span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="no">Empty</span><span class="p">,</span> <span class="no">Empty</span><span class="o">].</span><span class="n">left</span>   <span class="c1"># =&gt; Empty</span>
</code></pre></div>
<p>There are also methods <code>add_field_method_accessor</code> and <code>add_field_method_accessors</code> to add accessor/s selectively.</p>
]]></content>
  </entry>
  
</feed>
