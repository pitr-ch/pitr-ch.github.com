<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Pitr.ch]]></title>
  <link href="http://blog.pitr.ch/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://blog.pitr.ch/"/>
  <updated>2014-02-08T17:06:11+01:00</updated>
  <id>http://blog.pitr.ch/</id>
  <author>
    <name><![CDATA[Petr Chalupa]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to debug deadlocks or fatal errors]]></title>
    <link href="http://blog.pitr.ch/blog/2013/11/27/how-to-debug-deadlocks-or-fatal-errors/"/>
    <updated>2013-11-27T21:14:00+01:00</updated>
    <id>http://blog.pitr.ch/blog/2013/11/27/how-to-debug-deadlocks-or-fatal-errors</id>
    <content type="html"><![CDATA[<!-- more -->

<p>Few weeks back I was working on parallel execution in gem called <a href="https://github.com/iNecas/dynflow">Dynflow</a> and I ran into a deadlock. As you may know deadlock is an exception of class <code>fatal</code>. This special exception is not rescuable in fact none of the rescue blocks is evaluated when <code>fatal</code> is risen. This makes its debugging pretty hard. </p>

<p>Lets have a simple example generating deadlock.</p>
<div class="highlight"><pre><code class="ruby"><span class="nb">require</span> <span class="s1">&#39;thread&#39;</span>
<span class="c1"># cannot join on current main thread, it would wait forever</span>
<span class="no">Thread</span><span class="o">.</span><span class="n">current</span><span class="o">.</span><span class="n">join</span>
</code></pre></div>
<p>produces</p>
<div class="highlight"><pre><code class="text">./fatal.rb:3:in `join&#39;: deadlock detected (fatal)
    from ./fatal.rb:3:in `&lt;top (required)&gt;&#39;
    from -e:1:in `load&#39;
    from -e:1:in `&lt;main&gt;&#39;
</code></pre></div>
<p>Unfortunately event though rescue blocks are not evaluated ensure blocks are. I am using RubyMine and for some reason standard debugger breakpoint does not work in ensure block on line 6 at following example.</p>
<div class="highlight"><pre><code class="ruby"><span class="nb">require</span> <span class="s1">&#39;thread&#39;</span>

<span class="k">begin</span>
  <span class="no">Thread</span><span class="o">.</span><span class="n">current</span><span class="o">.</span><span class="n">join</span>
<span class="k">ensure</span>
  <span class="nb">p</span> <span class="vg">$!</span> <span class="k">if</span> <span class="vg">$!</span>
<span class="k">end</span>
</code></pre></div>
<p>Produces following output without stopping on line 6.</p>
<div class="highlight"><pre><code class="text">#&lt;fatal: deadlock detected&gt;
./fatal.rb:4:in `join&#39;: deadlock detected (fatal)
    from ./fatal.rb:4:in `&lt;top (required)&gt;&#39;
    from -e:1:in `load&#39;
    from -e:1:in `&lt;main&gt;&#39;
</code></pre></div>
<p>I could not google any solution but there is a nice trick. <a href="http://pryrepl.org/">Pry</a> can be used in ensure block.</p>
<div class="highlight"><pre><code class="ruby"><span class="nb">require</span> <span class="s1">&#39;thread&#39;</span>

<span class="k">begin</span>
  <span class="no">Thread</span><span class="o">.</span><span class="n">current</span><span class="o">.</span><span class="n">join</span>
<span class="k">ensure</span>
  <span class="nb">binding</span><span class="o">.</span><span class="n">pry</span> <span class="k">if</span> <span class="vg">$!</span>
<span class="k">end</span>
</code></pre></div>
<p>It will start pry session right after deadlock was risen giving an opportunity to inspect still running Ruby process to find out what is wrong. It&#39;s also very useful to combine <code>pry</code> with gem called <a href="https://github.com/pry/pry-stack_explorer">pry-stack_explorer</a> to able to inspect current stack like in debugger.</p>

<p>In the end it gave me enough information to find the problem. Hopefully it will save you some time if you run into similar issue.</p>

<p><em>Note: This examples are in Ruby 1.9.3. In Ruby 2.0.0 <code>Thread.current.join</code> raises nice <code>ThreadError</code> which is subclass of <code>StandardError</code> which can be debugged/inspected using usual means. Nevertheless similar deadlock like problem can rise in different situations in Ruby 2.0.0 too.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Algebrick - Bumping to v0.2 with new better type-defining-DSL]]></title>
    <link href="http://blog.pitr.ch/blog/2013/09/16/algebrick-bumping-to-v0-dot-2-with-new-better-type-defining-dsl/"/>
    <updated>2013-09-16T22:03:00+02:00</updated>
    <id>http://blog.pitr.ch/blog/2013/09/16/algebrick-bumping-to-v0-dot-2-with-new-better-type-defining-dsl</id>
    <content type="html"><![CDATA[<p>Finely I&#39;ve got an idea how to improve the old-not-so-good-DSL for Algebraic type definition.</p>

<!-- more -->

<p>With old DSL you would define Tree type as follows.</p>
<div class="highlight"><pre><code class="ruby"><span class="kp">include</span> <span class="ss">Algebrick</span><span class="p">:</span><span class="ss">:DSL</span>
<span class="n">type_def</span> <span class="k">do</span>
  <span class="n">tree</span> <span class="o">===</span> <span class="n">tip</span> <span class="o">|</span> <span class="n">node</span><span class="p">(</span><span class="ss">value</span><span class="p">:</span> <span class="no">Object</span><span class="p">,</span> <span class="ss">left</span><span class="p">:</span> <span class="n">tree</span><span class="p">,</span> <span class="ss">right</span><span class="p">:</span> <span class="n">tree</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>
<p>Although this looks quite nice and it&#39;s concise, it magically defines constants <code>Tree</code>, <code>Tip</code> and <code>Node</code>. Later when you come back to the code it&#39;s hard to  find where the constants are being defined. There is no <code>Tree = #something</code> in the source code. IDEs like RubyMine won&#39;t find the definition either.</p>

<p>I&#39;ve tried to improve the situation with manually setting the constants (this was never released).</p>
<div class="highlight"><pre><code class="ruby"><span class="no">Tree</span><span class="p">,</span> <span class="no">Tip</span><span class="p">,</span> <span class="no">Node</span> <span class="o">=</span> <span class="n">type_def</span> <span class="k">do</span>
  <span class="n">tree</span> <span class="o">===</span> <span class="n">tip</span> <span class="o">|</span> <span class="n">node</span><span class="p">(</span><span class="ss">value</span><span class="p">:</span> <span class="no">Object</span><span class="p">,</span> <span class="ss">left</span><span class="p">:</span> <span class="n">tree</span><span class="p">,</span> <span class="ss">right</span><span class="p">:</span> <span class="n">tree</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>
<p>But this has several other flows:</p>

<ol>
<li> If order of <code>tip</code> and <code>node</code> is changed in the definition, newly created types will end up in wrong constants since they are being returned by <code>#type_def</code> in order of first mention.</li>
<li> When more types are being defined in <code>#type_def</code>&#39;s block it will get messy very soon.</li>
</ol>

<p>Then I&#39;ve finally realized that because <code>#instance_eval</code> and <code>#instance_exec</code> does not change the <code>Module.nesting</code> of the blocks, the block can be evaluated inside a scope with DSL methods keeping the constants defined in original place. This behavior allows the following definition of Algebraic types.</p>
<div class="highlight"><pre><code class="ruby"><span class="no">Tree</span> <span class="o">=</span> <span class="no">Algebrick</span><span class="o">.</span><span class="n">type</span> <span class="k">do</span> <span class="o">|</span><span class="n">tree</span><span class="o">|</span>
  <span class="no">Tip</span>  <span class="o">=</span> <span class="n">type</span>
  <span class="no">Node</span> <span class="o">=</span> <span class="n">type</span> <span class="p">{</span> <span class="n">fields</span> <span class="ss">value</span><span class="p">:</span> <span class="no">Object</span><span class="p">,</span> <span class="ss">left</span><span class="p">:</span> <span class="n">tree</span><span class="p">,</span> <span class="ss">right</span><span class="p">:</span> <span class="n">tree</span> <span class="p">}</span>

  <span class="n">variants</span> <span class="no">Tip</span><span class="p">,</span> <span class="no">Node</span>
<span class="k">end</span>
</code></pre></div>
<p>It&#39;s been released in version 0.2.0.</p>

<h2>Version 0.2.2</h2>

<p>Version 0.2.1 just fixes release date of the gem. Version 0.2.2 adds minor improvement to the DSL. Field readers on products can be defined in DSL with methods <code>#readers *names</code> or <code>#all_readers</code> for all of them.</p>
<div class="highlight"><pre><code class="ruby"><span class="no">Node</span> <span class="o">=</span> <span class="n">type</span> <span class="k">do</span>
  <span class="n">fields</span> <span class="ss">value</span><span class="p">:</span> <span class="no">Object</span><span class="p">,</span> <span class="ss">left</span><span class="p">:</span> <span class="n">tree</span><span class="p">,</span> <span class="ss">right</span><span class="p">:</span> <span class="n">tree</span>
  <span class="n">all_readers</span>
<span class="k">end</span>
</code></pre></div>
<p>I hope you like the new DSL. </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to get object reference from inspection-string]]></title>
    <link href="http://blog.pitr.ch/blog/2013/06/03/how-to-get-object-reference-from-inspection-string/"/>
    <updated>2013-06-03T19:22:00+02:00</updated>
    <id>http://blog.pitr.ch/blog/2013/06/03/how-to-get-object-reference-from-inspection-string</id>
    <content type="html"><![CDATA[<!-- more -->

<p>Suppose there is a test failing and only an inspection string is shown in the error message.</p>
<div class="highlight"><pre><code class="text">#&lt;Class:0x007ff706e7eb68&gt;
</code></pre></div>
<p>It would be very convenient to retrieve a reference to the object for further inspection.
The following snippet will give you the object if it isn&#39;t garbage-collected yet.</p>
<div class="highlight"><pre><code class="ruby"><span class="no">ObjectSpace</span><span class="o">.</span><span class="n">_id2ref</span> <span class="s1">&#39;0x007ff706e7eb68&#39;</span><span class="o">.</span><span class="n">to_i</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
</code></pre></div>
<p>If you are asking about the strange bit shift <code>&gt;&gt; 1</code> as I am, I&#39;ll humbly point you to 
<a href="http://stackoverflow.com/questions/2818602/in-ruby-why-does-inspect-print-out-some-kind-of-object-id-which-is-different">http://stackoverflow.com/questions/2818602/in-ruby-why-does-inspect-print-out-some-kind-of-object-id-which-is-different</a> 
where you can find some explanation.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Making traps for future mistakes]]></title>
    <link href="http://blog.pitr.ch/blog/2013/06/02/make-traps-for-future-mistakes/"/>
    <updated>2013-06-02T10:58:00+02:00</updated>
    <id>http://blog.pitr.ch/blog/2013/06/02/make-traps-for-future-mistakes</id>
    <content type="html"><![CDATA[<p>I love to raise <code>ArgumentErrors</code>, <code>TypeErrors</code>, etc. whenever an API is misused. It prevents a lot of bugs. 
Recently I thought of another use for exceptions. </p>

<!-- more -->

<h2>Traps for future mistakes</h2>

<p>Suppose you are a developer of a gem and a method needs to be deprecated. Gem has version 0.1.3 and 
the method needs to warn about deprecation until version 0.2 and to be removed in version 0.2. 
It could be marked with <code>TODO</code> for removal in 0.2. Do you think that <code>TODO</code> will ensure timed removal? 
I don&#39;t. </p>

<p>I use exceptions to trap myself so I cannot do such mistakes.</p>
<div class="highlight"><pre><code class="ruby"><span class="k">raise</span> <span class="s1">&#39;remove deprecation&#39;</span> <span class="k">if</span> <span class="no">Algebrick</span><span class="o">.</span><span class="n">version</span> <span class="o">&gt;=</span> <span class="ss">Gem</span><span class="p">:</span><span class="ss">:Version</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;0.2&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">+</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
  <span class="nb">warn</span> <span class="s1">&#39;a_matcher +-&gt; {} is deprecated, it\&#39;ll be removed in 0.2&#39;</span>
  <span class="nb">self</span> <span class="o">-</span> <span class="n">block</span>
<span class="k">end</span>
</code></pre></div>
<p>If I use this I cannot forget about the deprecation removal. The gem will simply error when I bump version to 0.2 
telling me what I&#39;ve forgotten to fix.</p>

<h2>Another examples</h2>

<ul>
<li><p><strong>Monkey patch</strong> - When writing a monkey patch, a monkey patch should error when patched gem goes outside of
version range which was tested to work with the patch.</p>
<div class="highlight"><pre><code class="ruby"><span class="n">range</span> <span class="o">=</span> <span class="ss">Gem</span><span class="p">:</span><span class="ss">:Version</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;0.1&#39;</span><span class="p">)</span> <span class="o">.</span><span class="n">.</span><span class="o">.</span> <span class="ss">Gem</span><span class="p">:</span><span class="ss">:Version</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;0.3&#39;</span><span class="p">)</span>
<span class="n">range</span><span class="o">.</span><span class="n">cover?</span> <span class="ss">Gem</span><span class="p">:</span><span class="ss">:Version</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">a_patched_gem_version</span><span class="p">)</span> <span class="ow">or</span>
    <span class="k">raise</span> <span class="s2">&quot;monkey eats only banana version </span><span class="si">#{</span><span class="n">range</span><span class="si">}</span><span class="s2">&quot;</span>
</code></pre></div></li>
<li><p><strong>Internal API usage</strong> - Suppose a code is tied with an internal methods of Rails 3.0 and it&#39;s known that
an upgrade to 3.2 is planned at some point. An error should be thrown when Rails are updated.</p>
<div class="highlight"><pre><code class="ruby"><span class="ss">Gem</span><span class="p">:</span><span class="ss">:Version</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="no">Rails</span><span class="o">.</span><span class="n">version</span><span class="p">)</span> <span class="o">&lt;</span> <span class="ss">Gem</span><span class="p">:</span><span class="ss">:Version</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;3.1&#39;</span><span class="p">)</span> <span class="ow">or</span>
    <span class="k">raise</span> <span class="s1">&#39;revisit api usage&#39;</span>
</code></pre></div></li>
</ul>

<h2>Caution</h2>

<ul>
<li>  Checks like these should be done in class or module scope to be evaluated only once when loading. They should not be placed inside methods.</li>
<li>  <em>Update:</em> To avoid publishing faulty gem there should be a CI (e.g. Travis) set up so it will let you know that there is a problem when you bump the version and forget to run tests again.</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Justified - add missing causes to exceptions]]></title>
    <link href="http://blog.pitr.ch/blog/2013/06/01/justified-add-missing-causes-to-exceptions/"/>
    <updated>2013-06-01T19:52:00+02:00</updated>
    <id>http://blog.pitr.ch/blog/2013/06/01/justified-add-missing-causes-to-exceptions</id>
    <content type="html"><![CDATA[<p>I&#39;ve just published a new gem called <code>justified</code> which is adding missing causes to Ruby exceptions.
When an exception is risen because of another one it is stored in the new one, and backtrace is appended with following: </p>
<div class="highlight"><pre><code class="text">from caused by: (AnError) an ugly bug
from justified.rb:83:in `bad_code&#39;
from     ... skipped 4 lines
</code></pre></div>
<!-- more -->

<h2>Example</h2>

<p>Let&#39;s have following snippet:</p>
<div class="highlight"><pre><code class="ruby"><span class="k">class</span> <span class="nc">AnError</span> <span class="o">&lt;</span> <span class="no">StadardError</span><span class="p">;</span> <span class="k">end</span>

<span class="k">def</span> <span class="nf">bad_code</span>
  <span class="k">raise</span> <span class="no">AnError</span><span class="p">,</span> <span class="s1">&#39;an ugly bug&#39;</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">handle_error</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
  <span class="k">raise</span> <span class="no">AnError</span><span class="p">,</span> <span class="s1">&#39;something went wrong&#39;</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">do_something</span>
  <span class="n">bad_code</span>
<span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">error</span>
  <span class="n">handle_error</span> <span class="n">error</span>
<span class="k">end</span>

<span class="n">do_something</span>
</code></pre></div>
<p>When called it will produce:</p>
<div class="highlight"><pre><code class="text">justified.rb:93:in `handle_error&#39;: something went wrong (AnError)
    from justified.rb:89:in `rescue in do_something&#39;
    from justified.rb:87:in `do_something&#39;
    from justified.rb:96:in `&lt;top (required)&gt;&#39;
    from -e:1:in `load&#39;
    from -e:1:in `&lt;main&gt;&#39;
</code></pre></div>
<p>The real problem <code>an ugly bug</code> is <strong>hidden</strong>. What will happen when <code>justified</code> is used?</p>
<div class="highlight"><pre><code class="ruby"><span class="nb">require</span> <span class="s1">&#39;justified/stadard_error&#39;</span>

<span class="c1"># ... rest of the snipper</span>
</code></pre></div>
<p>It will produce:</p>
<div class="highlight"><pre><code class="text">justified.rb:93:in `handle_error&#39;: something went wrong (AnError)
    from justified.rb:89:in `rescue in do_something&#39;
    from justified.rb:87:in `do_something&#39;
    from justified.rb:96:in `&lt;top (required)&gt;&#39;
    from -e:1:in `load&#39;
    from -e:1:in `&lt;main&gt;&#39;
    from caused by: (AnError) an ugly bug
    from justified.rb:83:in `bad_code&#39;
    from     ... skipped 4 lines
</code></pre></div>
<p>Of course causes can be concatenated. </p>

<h2>Usage</h2>

<ul>
<li>  <code>require &#39;justified&#39;</code> to include <code>Justified::Error</code> to any exception you need manually</li>
<li>  <code>require &#39;justified/standard_error&#39;</code> to have causes in all exceptions which are kind of <code>StandardError</code></li>
</ul>

<h3>Behavior</h3>

<p>When an exception is risen inside rescue block a cause is automatically recorded.</p>
<div class="highlight"><pre><code class="ruby"><span class="n">e</span> <span class="o">=</span> <span class="k">begin</span>
      <span class="k">raise</span> <span class="s1">&#39;bug&#39;</span>
    <span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">error</span>
      <span class="k">raise</span> <span class="s1">&#39;this does not work&#39;</span>
    <span class="k">end</span> <span class="k">rescue</span> <span class="vg">$!</span>
<span class="n">e</span><span class="o">.</span><span class="n">cause</span><span class="o">.</span><span class="n">message</span> <span class="o">==</span> <span class="s1">&#39;bug&#39;</span> <span class="c1"># =&gt; true</span>
</code></pre></div>
<p>Cause can be set explicitly.</p>
<div class="highlight"><pre><code class="ruby"><span class="n">e</span> <span class="o">=</span> <span class="k">begin</span>
      <span class="k">raise</span> <span class="s1">&#39;bug&#39;</span>
    <span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">error</span>
      <span class="k">raise</span> <span class="no">StandardError</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;this does not work&#39;</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span>
    <span class="k">end</span> <span class="k">rescue</span> <span class="vg">$!</span>
<span class="n">e</span><span class="o">.</span><span class="n">cause</span><span class="o">.</span><span class="n">message</span> <span class="o">==</span> <span class="s1">&#39;bug&#39;</span> <span class="c1"># =&gt; true</span>
</code></pre></div>
<p>Or if signature of <code>.new</code> is changed cause can be set with a setter <code>#cause=</code></p>
<div class="highlight"><pre><code class="ruby"><span class="k">class</span> <span class="nc">InspectingError</span> <span class="o">&lt;</span> <span class="no">StandardError</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">object</span><span class="p">)</span>
    <span class="k">super</span> <span class="n">object</span><span class="o">.</span><span class="n">inspect</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">e</span> <span class="o">=</span> <span class="k">begin</span>
      <span class="k">raise</span> <span class="s1">&#39;bug&#39;</span>
    <span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">error</span>
      <span class="k">raise</span> <span class="no">InspectingError</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">a</span><span class="p">:</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">tap</span> <span class="p">{</span> <span class="o">|</span><span class="n">e</span><span class="o">|</span> <span class="n">e</span><span class="o">.</span><span class="n">cause</span> <span class="o">=</span> <span class="n">error</span> <span class="p">}</span>
    <span class="k">end</span> <span class="k">rescue</span> <span class="vg">$!</span>
<span class="n">e</span><span class="o">.</span><span class="n">cause</span><span class="o">.</span><span class="n">message</span> <span class="o">==</span> <span class="s1">&#39;bug&#39;</span> <span class="c1"># =&gt; true</span>
</code></pre></div>
<p>and</p>
<div class="highlight"><pre><code class="ruby"><span class="n">e</span> <span class="o">=</span> <span class="k">begin</span>
      <span class="k">raise</span> <span class="s1">&#39;bug&#39;</span>
    <span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">error</span>
      <span class="k">raise</span> <span class="no">InspectingError</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">a</span><span class="p">:</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
    <span class="k">end</span> <span class="k">rescue</span> <span class="vg">$!</span>
<span class="n">e</span><span class="o">.</span><span class="n">cause</span><span class="o">.</span><span class="n">message</span> <span class="o">==</span> <span class="s1">&#39;bug&#39;</span> <span class="c1"># =&gt; true</span>
</code></pre></div>
<p>will work as well.</p>

<h2>Do you wish to know more?</h2>

<ul>
<li>  Documentation: <a href="http://blog.pitr.ch/justified">http://blog.pitr.ch/justified</a></li>
<li>  Source: <a href="https://github.com/pitr-ch/justified">https://github.com/pitr-ch/justified</a></li>
<li>  Blog: <a href="http://blog.pitr.ch/blog/categories/justified/">http://blog.pitr.ch/blog/categories/justified/</a></li>
</ul>
]]></content>
  </entry>
  
</feed>
