<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: algebrick | Pitr.ch]]></title>
  <link href="http://blog.pitr.ch/blog/categories/algebrick/atom.xml" rel="self"/>
  <link href="http://blog.pitr.ch/"/>
  <updated>2013-11-27T21:54:18+01:00</updated>
  <id>http://blog.pitr.ch/</id>
  <author>
    <name><![CDATA[Petr Chalupa]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Algebrick - Bumping to v0.2 with new better type-defining-DSL]]></title>
    <link href="http://blog.pitr.ch/blog/2013/09/16/algebrick-bumping-to-v0-dot-2-with-new-better-type-defining-dsl/"/>
    <updated>2013-09-16T22:03:00+02:00</updated>
    <id>http://blog.pitr.ch/blog/2013/09/16/algebrick-bumping-to-v0-dot-2-with-new-better-type-defining-dsl</id>
    <content type="html"><![CDATA[<p>Finely I&#39;ve got an idea how to improve the old-not-so-good-DSL for Algebraic type definition.</p>

<!-- more -->

<p>With old DSL you would define Tree type as follows.</p>
<div class="highlight"><pre><code class="ruby"><span class="kp">include</span> <span class="ss">Algebrick</span><span class="p">:</span><span class="ss">:DSL</span>
<span class="n">type_def</span> <span class="k">do</span>
  <span class="n">tree</span> <span class="o">===</span> <span class="n">tip</span> <span class="o">|</span> <span class="n">node</span><span class="p">(</span><span class="ss">value</span><span class="p">:</span> <span class="no">Object</span><span class="p">,</span> <span class="ss">left</span><span class="p">:</span> <span class="n">tree</span><span class="p">,</span> <span class="ss">right</span><span class="p">:</span> <span class="n">tree</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>
<p>Although this looks quite nice and it&#39;s concise, it magically defines constants <code>Tree</code>, <code>Tip</code> and <code>Node</code>. Later when you come back to the code it&#39;s hard to  find where the constants are being defined. There is no <code>Tree = #something</code> in the source code. IDEs like RubyMine won&#39;t find the definition either.</p>

<p>I&#39;ve tried to improve the situation with manually setting the constants (this was never released).</p>
<div class="highlight"><pre><code class="ruby"><span class="no">Tree</span><span class="p">,</span> <span class="no">Tip</span><span class="p">,</span> <span class="no">Node</span> <span class="o">=</span> <span class="n">type_def</span> <span class="k">do</span>
  <span class="n">tree</span> <span class="o">===</span> <span class="n">tip</span> <span class="o">|</span> <span class="n">node</span><span class="p">(</span><span class="ss">value</span><span class="p">:</span> <span class="no">Object</span><span class="p">,</span> <span class="ss">left</span><span class="p">:</span> <span class="n">tree</span><span class="p">,</span> <span class="ss">right</span><span class="p">:</span> <span class="n">tree</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>
<p>But this has several other flows:</p>

<ol>
<li> If order of <code>tip</code> and <code>node</code> is changed in the definition, newly created types will end up in wrong constants since they are being returned by <code>#type_def</code> in order of first mention.</li>
<li> When more types are being defined in <code>#type_def</code>&#39;s block it will get messy very soon.</li>
</ol>

<p>Then I&#39;ve finally realized that because <code>#instance_eval</code> and <code>#instance_exec</code> does not change the <code>Module.nesting</code> of the blocks, the block can be evaluated inside a scope with DSL methods keeping the constants defined in original place. This behavior allows the following definition of Algebraic types.</p>
<div class="highlight"><pre><code class="ruby"><span class="no">Tree</span> <span class="o">=</span> <span class="no">Algebrick</span><span class="o">.</span><span class="n">type</span> <span class="k">do</span> <span class="o">|</span><span class="n">tree</span><span class="o">|</span>
  <span class="no">Tip</span>  <span class="o">=</span> <span class="n">type</span>
  <span class="no">Node</span> <span class="o">=</span> <span class="n">type</span> <span class="p">{</span> <span class="n">fields</span> <span class="ss">value</span><span class="p">:</span> <span class="no">Object</span><span class="p">,</span> <span class="ss">left</span><span class="p">:</span> <span class="n">tree</span><span class="p">,</span> <span class="ss">right</span><span class="p">:</span> <span class="n">tree</span> <span class="p">}</span>

  <span class="n">variants</span> <span class="no">Tip</span><span class="p">,</span> <span class="no">Node</span>
<span class="k">end</span>
</code></pre></div>
<p>It&#39;s been released in version 0.2.0.</p>

<h2>Version 0.2.2</h2>

<p>Version 0.2.1 just fixes release date of the gem. Version 0.2.2 adds minor improvement to the DSL. Field readers on products can be defined in DSL with methods <code>#readers *names</code> or <code>#all_readers</code> for all of them.</p>
<div class="highlight"><pre><code class="ruby"><span class="no">Node</span> <span class="o">=</span> <span class="n">type</span> <span class="k">do</span>
  <span class="n">fields</span> <span class="ss">value</span><span class="p">:</span> <span class="no">Object</span><span class="p">,</span> <span class="ss">left</span><span class="p">:</span> <span class="n">tree</span><span class="p">,</span> <span class="ss">right</span><span class="p">:</span> <span class="n">tree</span>
  <span class="n">all_readers</span>
<span class="k">end</span>
</code></pre></div>
<p>I hope you like the new DSL. </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Algebrick - bump to version 0.1.2]]></title>
    <link href="http://blog.pitr.ch/blog/2013/06/01/algebrick-bump-to-version-0-1-2/"/>
    <updated>2013-06-01T17:22:00+02:00</updated>
    <id>http://blog.pitr.ch/blog/2013/06/01/algebrick-bump-to-version-0-1-2</id>
    <content type="html"><![CDATA[<!-- more -->

<h2>Call <code>#type_def</code> directly</h2>

<p><code>Algebraic::DSL</code> module does not have to be extended into your module to access <code>#type_def</code> any more.
It can be now called directly with passing the base module to define the new types.</p>
<div class="highlight"><pre><code class="ruby"><span class="no">Algebrick</span><span class="o">.</span><span class="n">type_def</span> <span class="nb">self</span> <span class="k">do</span>
  <span class="n">boolean</span> <span class="o">===</span> <span class="no">TrueClass</span> <span class="o">|</span> <span class="no">FalseClass</span>
<span class="k">end</span>
</code></pre></div>
<h2>Wrong field</h2>

<p>When wrong field is accessed it will now raise an <code>ArgummentError</code> instead of silently returning <code>nil</code></p>
<div class="highlight"><pre><code class="ruby"><span class="no">Algebrick</span><span class="o">.</span><span class="n">type_def</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">tree</span> <span class="o">===</span> <span class="n">empty</span> <span class="o">|</span> <span class="n">tree</span><span class="p">(</span><span class="ss">value</span><span class="p">:</span> <span class="nb">Integer</span><span class="p">,</span> <span class="ss">left</span><span class="p">:</span> <span class="n">tree</span><span class="p">,</span> <span class="ss">right</span><span class="p">:</span> <span class="n">tree</span><span class="p">)</span>
<span class="k">end</span>
<span class="no">Tree</span><span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="no">Empty</span><span class="p">,</span> <span class="no">Empty</span><span class="o">][</span><span class="ss">:middle</span><span class="o">]</span> <span class="k">rescue</span> <span class="vg">$!</span> 
<span class="c1"># =&gt; #&lt;ArgumentError: uknown field :middle&gt;</span>
</code></pre></div>
<h2>Access fields by method</h2>

<p>Call <code>#add_all_field_method_accessors</code> on a product type to get access to fields by methods.</p>
<div class="highlight"><pre><code class="ruby"><span class="no">Tree</span><span class="o">.</span><span class="n">add_all_field_method_accessors</span>
<span class="no">Tree</span><span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="no">Empty</span><span class="p">,</span> <span class="no">Empty</span><span class="o">].</span><span class="n">left</span>   <span class="c1"># =&gt; Empty</span>
</code></pre></div>
<p>There are also methods <code>add_field_method_accessor</code> and <code>add_field_method_accessors</code> to add accessor/s selectively.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Algebrick - bump to version 0.1.1]]></title>
    <link href="http://blog.pitr.ch/blog/2013/06/01/algebrick-bump-to-version-0-1-1/"/>
    <updated>2013-06-01T17:22:00+02:00</updated>
    <id>http://blog.pitr.ch/blog/2013/06/01/algebrick-bump-to-version-0-1-1</id>
    <content type="html"><![CDATA[<!-- more -->

<h2>Method <code>#+</code> is deprecated</h2>
<div class="highlight"><pre><code class="ruby"><span class="no">Leaf</span><span class="o">.</span><span class="p">(</span><span class="o">~</span><span class="n">any</span><span class="p">)</span> <span class="o">+-&gt;</span> <span class="n">v</span> <span class="p">{</span> <span class="n">v</span><span class="o">*</span><span class="mi">2</span> <span class="p">}</span>
</code></pre></div>
<p><code>#-</code>, <code>#&gt;&gt;</code> and <code>#case</code> should be used instead</p>
<div class="highlight"><pre><code class="ruby"><span class="no">Leaf</span><span class="o">.</span><span class="p">(</span><span class="o">~</span><span class="n">any</span><span class="p">)</span> <span class="o">--&gt;</span> <span class="n">v</span> <span class="p">{</span> <span class="n">v</span><span class="o">*</span><span class="mi">2</span> <span class="p">}</span>
<span class="no">Leaf</span><span class="o">.</span><span class="p">(</span><span class="o">~</span><span class="n">any</span><span class="p">)</span> <span class="o">&gt;&gt;-&gt;</span> <span class="n">v</span> <span class="p">{</span> <span class="n">v</span><span class="o">*</span><span class="mi">2</span> <span class="p">}</span>
<span class="no">Leaf</span><span class="o">.</span><span class="p">(</span><span class="o">~</span><span class="n">any</span><span class="p">)</span><span class="o">.</span><span class="n">case</span> <span class="p">{</span> <span class="o">|</span><span class="n">v</span><span class="o">|</span> <span class="n">v</span><span class="o">*</span><span class="mi">2</span> <span class="p">}</span>
</code></pre></div>
<h2>Delegation from Types</h2>

<p><code>#-</code>, <code>#&gt;&gt;</code> and <code>#case</code> are now delegated from types, it simplifies calls on atom types</p>
<div class="highlight"><pre><code class="ruby"><span class="no">None</span><span class="o">.</span><span class="n">to_m</span> <span class="o">&gt;&gt;</span> <span class="kp">nil</span> <span class="c1"># to_m can be omitted</span>
<span class="no">None</span> <span class="o">&gt;&gt;</span> <span class="kp">nil</span>        
</code></pre></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Algebrick - Algebraic types and pattern matching for Ruby]]></title>
    <link href="http://blog.pitr.ch/blog/2013/05/14/algebrick-algebraic-types-and-pattern-matching-for-ruby/"/>
    <updated>2013-05-14T21:19:00+02:00</updated>
    <id>http://blog.pitr.ch/blog/2013/05/14/algebrick-algebraic-types-and-pattern-matching-for-ruby</id>
    <content type="html"><![CDATA[<p>I&#39;ve just released a new gem <code>algebrick</code> which brings <strong>algebraic types</strong> and <strong>pattern matching</strong> to Ruby.
It&#39;s not as powerfull as Haskell&#39;s but it can still be quite useful. Let me give you a quick taste of the syntax.</p>

<!-- more -->

<h2>Quick example</h2>

<p>Load DSL for type definition and define some algebraic types</p>
<div class="highlight"><pre><code class="ruby"><span class="kp">extend</span> <span class="ss">Algebrick</span><span class="p">:</span><span class="ss">:DSL</span>

<span class="n">type_def</span> <span class="k">do</span>
  <span class="n">tree</span> <span class="o">===</span> <span class="n">empty</span> <span class="o">|</span> <span class="n">leaf</span><span class="p">(</span><span class="nb">Integer</span><span class="p">)</span> <span class="o">|</span> <span class="n">node</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>
<p>Now types <code>Tree(Empty | Leaf | Node)</code>, <code>Empty</code>, <code>Leaf(Integer)</code> and <code>Node(Tree, Tree)</code> are defined.
Lets add some methods, don&#39;t miss the <strong>pattern matching</strong> example.</p>
<div class="highlight"><pre><code class="ruby"><span class="k">module</span> <span class="nn">Tree</span>
  <span class="c1"># compute depth of a tree</span>
  <span class="k">def</span> <span class="nf">depth</span>
    <span class="n">match</span> <span class="nb">self</span><span class="p">,</span>
          <span class="no">Empty</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="p">,</span>
          <span class="no">Leaf</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span>
          <span class="c1"># ~ will store and pass matched parts to variables left and right</span>
          <span class="no">Node</span><span class="o">.</span><span class="p">(</span><span class="o">~</span><span class="n">any</span><span class="p">,</span> <span class="o">~</span><span class="n">any</span><span class="p">)</span> <span class="o">--&gt;</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="k">do</span>
            <span class="mi">1</span> <span class="o">+</span> <span class="o">[</span><span class="n">left</span><span class="o">.</span><span class="n">depth</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">depth</span><span class="o">].</span><span class="n">max</span>
          <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>Methods are defined on <strong>all</strong> values of type Tree</p>
<div class="highlight"><pre><code class="ruby"><span class="no">Empty</span><span class="o">.</span><span class="n">depth</span>                                        <span class="c1"># =&gt; 0</span>
<span class="no">Leaf</span><span class="o">[</span><span class="mi">10</span><span class="o">].</span><span class="n">depth</span>                                     <span class="c1"># =&gt; 1</span>
<span class="no">Node</span><span class="o">[</span><span class="no">Leaf</span><span class="o">[</span><span class="mi">4</span><span class="o">]</span><span class="p">,</span> <span class="no">Empty</span><span class="o">].</span><span class="n">depth</span>                         <span class="c1"># =&gt; 2</span>
<span class="no">Node</span><span class="o">[</span><span class="no">Empty</span><span class="p">,</span> <span class="no">Node</span><span class="o">[</span><span class="no">Leaf</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">,</span> <span class="no">Empty</span><span class="o">]].</span><span class="n">depth</span>            <span class="c1"># =&gt; 3</span>
</code></pre></div>
<h2>Do you wish to know more?</h2>

<ul>
<li>  Documentation: <a href="http://blog.pitr.ch/algebrick">http://blog.pitr.ch/algebrick</a></li>
<li>  Source: <a href="https://github.com/pitr-ch/algebrick">https://github.com/pitr-ch/algebrick</a></li>
<li>  Blog: <a href="http://blog.pitr.ch/blog/categories/algebrick/">http://blog.pitr.ch/blog/categories/algebrick/</a></li>
</ul>
]]></content>
  </entry>
  
</feed>
